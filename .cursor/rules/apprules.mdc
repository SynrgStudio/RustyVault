---
alwaysApply: false
---
## Consideraciones GUI Espec√≠ficas

### Responsividad
- NUNCA ejecutes robocopy en el UI thread
- Usa `ctx.request_repaint()` para actualizar UI cuando llegan updates
- Implementa debouncing para inputs que cambien frecuentemente
- Usa `egui::Ui::spinner()` para indicar operaciones en progreso

### UX Considerations
- Implementa validaci√≥n de inputs en tiempo real
- Muestra tooltips para opciones avanzadas
- Persistir ventana size/position entre sesiones
- Implementa drag & drop para selecci√≥n de carpetas
- Provee shortcuts de teclado para acciones comunes

### File System Integration
- Usa file dialogs nativos (`rfd`) para mejor UX
- Implementa preview de archivos/carpetas seleccionadas
- Muestra iconos apropiados para tipos de archivo
- Integra con Explorer context menu cuando sea posible

### Error Handling en UI
- Muestra errores en modals o notifications, no en console
- Implementa retry mechanisms accesibles desde UI
- Logga errores pero tambi√©n muestra mensajes user-friendly
- Permte al usuario reportar errores f√°cilmente### UI Layout con egui
```rust
fn render_main_panel(&mut self, ui: &mut egui::Ui) {
    ui.horizontal(|ui| {
        ui.label("Source:");
        if ui.button("üìÅ Browse").clicked() {
            if let Some(path) = rfd::FileDialog::new().pick_folder() {
                self.config.source_path = path;
            }
        }
        ui.text_edit_singleline(&mut self.config.source_path_str);
    });
    
    // Progress bar cuando hay backup corriendo
    if let BackupState::Running { progress, current_file } = &self.backup_state {
        ui.add(egui::ProgressBar::new(*progress).text(current_file));
    }
    
    // Botones de acci√≥n
    ui.horizontal(|ui| {
        if ui.button("Start Backup").clicked() {
            self.start_backup();
        }
        if ui.button("Schedule").clicked() {
            self.show_schedule_dialog = true;
        }
    });
}
```# Cursor Rules para Aplicaci√≥n de Backup Autom√°tico - Rust + Robocopy

## Contexto del Proyecto
Est√°s ayudando a desarrollar una aplicaci√≥n GUI en Rust que automatiza backups de directorios usando robocopy en Windows. La aplicaci√≥n debe ser robusta, eficiente y f√°cil de usar con una interfaz gr√°fica intuitiva.

## Principios de Desarrollo

### Rust Best Practices
- SIEMPRE usa `Result<T, E>` para manejo de errores, nunca `.unwrap()` o `.expect()` en c√≥digo de producci√≥n
- Prefiere `anyhow::Result` para errores de aplicaci√≥n y `thiserror` para errores de librer√≠a
- Usa `tracing` en lugar de `println!` para logging
- Implementa `From` traits para conversiones de errores cuando sea apropiado
- Prefiere structs tipadas sobre tipos primitivos para mayor seguridad de tipos

### Arquitectura y Dise√±o
- Separa la l√≥gica de negocio del c√≥digo de UI usando arquitectura MVC/MVP
- Usa el patr√≥n Command para operaciones de backup
- Implementa comunicaci√≥n async entre UI thread y worker threads
- Dise√±a pensando en responsividad - nunca bloquees el UI thread
- Usa channels (mpsc) para comunicaci√≥n thread-safe entre backend y frontend
- Implementa configuraci√≥n via archivos TOML con `serde`
- Dise√±a pensando en testing - separa l√≥gica de UI de l√≥gica de negocio

### Windows/Robocopy Espec√≠fico
- Valida siempre rutas de Windows (UNC paths, paths largos, caracteres especiales)
- Parsea correctamente los c√≥digos de salida de robocopy (0, 1, 2, 4, 8, 16, etc.)
- Maneja timeouts apropiados para operaciones de red
- Considera VSS (Volume Shadow Copy) para archivos en uso
- Implementa retry logic para fallos de red/temporales

## Estructura de C√≥digo Preferida

### GUI Framework (egui recomendado)
```rust
use eframe::egui;
use std::sync::mpsc;
use anyhow::Result;

#[derive(Default)]
struct BackupApp {
    config: BackupConfig,
    backup_state: BackupState,
    progress_rx: Option<mpsc::Receiver<ProgressUpdate>>,
    logs: Vec<LogEntry>,
}

impl eframe::App for BackupApp {
    fn update(&mut self, ctx: &egui::Context, _frame: &mut eframe::Frame) {
        // UI logic aqu√≠
        self.handle_progress_updates();
        self.render_ui(ctx);
    }
}
```

### Arquitectura Thread-Safe
```rust
use std::sync::mpsc;
use tokio::task;

struct BackupManager {
    progress_tx: mpsc::Sender<ProgressUpdate>,
}

impl BackupManager {
    fn start_backup(&self, config: BackupConfig) -> Result<()> {
        let progress_tx = self.progress_tx.clone();
        
        task::spawn(async move {
            // L√≥gica de backup en background thread
            execute_backup_with_progress(config, progress_tx).await
        });
        
        Ok(())
    }
}
```

### Error Handling Pattern
```rust
use anyhow::{Context, Result};

fn backup_directory(source: &Path, dest: &Path) -> Result<BackupResult> {
    validate_paths(source, dest)
        .context("Path validation failed")?;
    
    execute_robocopy(source, dest)
        .context("Robocopy execution failed")?;
    
    Ok(BackupResult::Success)
}
```

### Configuraci√≥n
```rust
use serde::{Deserialize, Serialize};

#[derive(Debug, Deserialize, Serialize)]
struct BackupConfig {
    source_paths: Vec<PathBuf>,
    destination: PathBuf,
    schedule: Schedule,
    robocopy_options: RobocopyOptions,
    notifications: NotificationConfig,
}
```

## Librer√≠as Recomendadas

### GUI Framework
- `eframe` + `egui` - GUI moderna, nativa y cross-platform (RECOMENDADO)
- `tauri` - Si prefieres web technologies con Rust backend
- `iced` - Alternativa inspirada en Elm
- `slint` - GUI declarativa (alternativa)

### Threading y Async
- `tokio` - Runtime async para operaciones de background
- `std::sync::mpsc` - Channels para comunicaci√≥n UI ‚Üî Backend
- `parking_lot` - Sincronizaci√≥n m√°s eficiente que std

### Esenciales
- `anyhow` - Error handling simplificado
- `tracing` + `tracing-subscriber` - Logging estructurado
- `serde` + `toml` - Serializaci√≥n de configuraci√≥n

### Utilidades
- `walkdir` - Para traversal de directorios
- `chrono` - Manejo de fechas y tiempos
- `notify-rust` - Notificaciones del sistema
- `regex` - Para parsing de output de robocopy
- `rfd` - File dialogs nativos para selecci√≥n de directorios
- `dirs` - Para encontrar directorios del sistema (config, data)

## Patrones de C√≥digo Espec√≠ficos

### Manejo de State en GUI
```rust
#[derive(Debug, Clone)]
enum BackupState {
    Idle,
    Running { progress: f32, current_file: String },
    Completed { summary: BackupSummary },
    Error { message: String },
}

#[derive(Debug, Clone)]
enum ProgressUpdate {
    FileStarted(String),
    ProgressChanged(f32),
    Completed(BackupSummary),
    Error(String),
}
```

### Comunicaci√≥n Thread-Safe
```rust
fn spawn_backup_task(
    config: BackupConfig,
    progress_tx: mpsc::Sender<ProgressUpdate>,
) {
    std::thread::spawn(move || {
        let result = execute_backup_with_progress(&config, &progress_tx);
        
        match result {
            Ok(summary) => {
                let _ = progress_tx.send(ProgressUpdate::Completed(summary));
            }
            Err(e) => {
                let _ = progress_tx.send(ProgressUpdate::Error(e.to_string()));
            }
        }
    });
}
```

### Validaci√≥n de Rutas Windows
```rust
fn validate_windows_path(path: &Path) -> Result<()> {
    // Verifica existencia, permisos, caracteres v√°lidos
    // Maneja UNC paths \\server\share
    // Considera MAX_PATH limitations
}
```

### Ejecuci√≥n de Robocopy
```rust
fn execute_robocopy(cmd: &RobocopyCommand) -> Result<RobocopyResult> {
    let output = Command::new("robocopy")
        .args(&cmd.build_args())
        .output()
        .context("Failed to execute robocopy")?;
    
    parse_robocopy_result(output)
}
```

### Testing
- Usa `tempfile` para tests que requieren filesystem
- Mock robocopy calls en tests unitarios
- Testa l√≥gica de negocio separadamente de UI
- Implementa integration tests con directorios temporales
- Considera visual regression tests para UI critical paths

## Consideraciones de Seguridad
- Valida inputs de usuario para prevenir command injection
- Sanitiza rutas antes de pasar a robocopy
- Loggea operaciones sin exponer informaci√≥n sensible
- Maneja credenciales de red de forma segura

## Observabilidad y Debugging
- Usa structured logging con campos contextuales
- Implementa logging UI panel para debugging en desarrollo
- Loggea timing de operaciones largas
- Incluye informaci√≥n de sistema relevante (espacio en disco, permisos)
- Implementa crash reporting y auto-recovery
- Permite al usuario exportar logs para soporte t√©cnico

## Performance
- Considera paralelismo solo para m√∫ltiples backups independientes
- Optimiza robocopy flags seg√∫n el caso de uso
- Implementa progress reporting sin impactar performance
- Usa lazy evaluation donde sea apropiado

## Manejo de Errores Espec√≠ficos

### C√≥digos de Salida Robocopy
- 0: Sin cambios, no se copiaron archivos
- 1: Archivos copiados exitosamente  
- 2: Hay archivos/directorios adicionales en destino
- 4: Archivos mismatched detectados
- 8: Fall√≥ al copiar algunos archivos
- 16: Error serio - robocopy no ejecut√≥

### Recovery Strategies  
- Retry autom√°tico para errores de red (c√≥digos 32, 64)
- Logging detallado de archivos que fallan
- Opci√≥n de continuar vs abortar en errores

## Code Style
- Usa `rustfmt` con configuraci√≥n est√°ndar
- Prefer `match` sobre m√∫ltiples `if let`
- Documenta funciones p√∫blicas con `///`
- Usa nombres descriptivos para variables y funciones
- Mant√©n funciones peque√±as y con responsabilidad √∫nica

## Testing Strategy
- Unit tests para l√≥gica de parsing y validaci√≥n (separada de UI)
- Integration tests para flujos completos de backup
- Property-based tests para validaci√≥n de rutas
- Mock UI interactions para testing de state management
- Benchmarks para operaciones cr√≠ticas de performance

## Deployment Considerations
- Compila con `--release` para distribuci√≥n
- Considera code signing para Windows
- Implementa auto-updater si es necesario
- Incluye installer con dependencias (Visual C++ Runtime)
- Testa en diferentes versiones de Windows

Cuando generes c√≥digo, aseg√∫rate de seguir estos patrones y considera estos aspectos espec√≠ficos de GUI apps y el dominio de backups en Windows.